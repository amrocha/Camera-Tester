import FileReader
from Coordinate import Coordinate
from MetricsResult import MetricsResult
import subprocess, math
import time
from datetime import datetime
#import numpy as np
#import matplotlib.pyplot as plt
#from scipy.optimize import fmin_cobyla
#from decimal import *

class Scenario:
    """
    Class containing information for a test scenario

    variables
    scenarioID: the unique identifier for this scenario
    coreLog: the path and filename for the core log used to generate this scenario
    gpsLog: the path and filename for the gps log used to generate this scenario
    timeOffset: the timestamp difference used to compare points in time between the two log files
    maxRadius: the maximum distance a point from the core log can be from a corresponding gps log point for it to be considered accurate
    """
    def __init__ (self, scenarioID, maxRadius, txtDir, gpsLog, coreLog=None, timeOffset=None):
        self.scenarioID = scenarioID
        self.date = datetime.utcnow()
        self.txtDir = txtDir
        self.coreLog = coreLog
        self.gpsLog = gpsLog
        self.timeOffset = timeOffset
        self.maxRadius = maxRadius

    def run(self):
        if self.coreLog == None:
            self.coreLog = self.runCamSim()
        self.core_entries = FileReader.parseCoreLog(self.coreLog)
        self.gps_entries = FileReader.parseGpsLog(self.gpsLog)
        self.timeOffset = self.calculateTimeOffset()
        distances = self.comparePath()
        self.calculateMetrics(self.core_entries, distances)
        self.createDataSheet()
        self.export()
        print "Minimum Distance"
        print min(distances)
        print "Maximum Distance"
        print max(distances)

        print 'id: ', self.scenarioID
        print 'core log file: ', self.coreLog
        print 'gps log file: ', self.gpsLog
        print 'time offset: ', self.timeOffset
        print 'maximum radius: ', self.maxRadius
        print 'number of core file entries: ', len(self.core_entries)
        print 'number of gps file entries: ', len(self.gps_entries)

    #this method will call camsim, wait until it completes running, and then return the path and filename that was generated by camsim
    def runCamSim(self):
        #call camsim
        CamSimExe = "CamSimDummyApp.exe"
        CamSimArgs = ["aaa", "bbb", "ccc"]
        subprocess.call([CamSimExe] + CamSimArgs)

        #wait

        #obtain and return path and filename of the log file
        return 'Corefile.log'

    """
    Calculates the difference in timestamps between the two files
    The GPS log contains timestamps generated during the time when the video was created
    The Core log contains timestamps generated during the run of camsim
    """
    def calculateTimeOffset(self):
        return 33

    """
    coreLogPath is the list of Coordinates from the path that has been matched with the GPS file
    pathDistances is the list of calculated distances between each point in coreLogPath and the GPS path. The coordinate coreLogPath[i] has a distance of pathDistances[i].
    
    for now I've assumed that a tracknum of -1 is used in coreLogPath at any point in time when nothing was detected
    this may need to be changed depending on how the path comparison is implemented
    """
    def calculateMetrics(self, coreLogPath, pathDistances):
        #all counters with an array of length two have the twenty minute segment counter at index 0 and the total counter at index 1
        #index 0 resets every twenty minutes of footage
        
        #for calculating the detection percent
        numUndetected = [0,0]
        
        #for calculating id changes
        previousID = [-1,-1]
        numIDChanges = [-1,-1]
        
        #for calculating the positional accuracy metrics
        totalDist = [0,0]
        minDist = [99999, 99999]
        maxDist = [-1,-1]
        numAboveRadius = [0,0]

        #used for 20 minute time segments
        timeSegmentStart = coreLogPath[0].time[:4] + '00.000'
        timeSegmentStartIndex = 0
        self.twentyMinuteResults = []
        
        for i in range(0, len(coreLogPath)):
            # if 20 minutes have passed, create the results. Then start the next twenty minute segment
            if (int(coreLogPath[i].time[2:4]) - int(timeSegmentStart[2:4]))%60 >= 20:
                self.twentyMinuteResults.append(MetricsResult(i - timeSegmentStartIndex, timeSegmentStart, self.addTimeStamps(timeSegmentStart, '001959.999'),
                                                         numUndetected[0], numIDChanges[0], minDist[0], maxDist[0], totalDist[0], numAboveRadius[0]))
                timeSegmentStartIndex = i
                timeSegmentStart = self.addTimeStamps(timeSegmentStart, '002000.00')
                
                #reset all twenty minute segment counters
                numUndetected[0] = 0
                previousID[0] = -1
                numIDChanges[0] = -1
                totalDist[0] = 0
                minDist[0] = 99999
                maxDist[0] = -1
                numAboveRadius[0] = 0
            
            if coreLogPath[i].tn < 0:
                numUndetected[0] += 1
                numUndetected[1] += 1
            else:
                if coreLogPath[i].tn != previousID[0]:
                    previousID[0] = coreLogPath[i].tn
                    numIDChanges[0] += 1
                if coreLogPath[i].tn != previousID[1]:
                    previousID[1] = coreLogPath[i].tn
                    numIDChanges[1] += 1
                totalDist[0] += pathDistances[i]
                totalDist[1] += pathDistances[i]
                if pathDistances[i] < minDist[0]:
                    minDist[0] = pathDistances[i]
                if pathDistances[i] < minDist[1]:
                    minDist[1] = pathDistances[i]
                if pathDistances[i] > maxDist[0]:
                    maxDist[0] = pathDistances[i]
                if pathDistances[i] > maxDist[1]:
                    maxDist[1] = pathDistances[i]
                if pathDistances[i] > self.maxRadius:
                    numAboveRadius[0] += 1
                    numAboveRadius[1] += 1

        #add last segment
        self.twentyMinuteResults.append(MetricsResult(len(coreLogPath) - timeSegmentStartIndex, timeSegmentStart, coreLogPath[len(coreLogPath) - 1].time,
                                                 numUndetected[0], numIDChanges[0], minDist[0], maxDist[0], totalDist[0], numAboveRadius[0]))
        
        #create the total result
        self.totalResult = MetricsResult(len(coreLogPath), coreLogPath[0].time[:4] + '00.000', coreLogPath[len(coreLogPath) - 1].time,
                                         numUndetected[1], numIDChanges[1], minDist[1], maxDist[1], totalDist[1], numAboveRadius[1])
        
    #adds two timestamps of the format 'HHMMSS.mmm' 
    def addTimeStamps(self, time1, time2):
        second = float(time1[4:]) + float(time2[4:])
        minute = int(time1[2:4]) + int(time2[2:4])
        hour = int(time1[:2]) + int(time2[:2])
        if second >= 60:
            second %= 60
            minute += 1
        if minute >= 60:
            minute %= 60
            hour += 1
        hour %= 24

        if second < 10:
            second = '0' + str(second)
        else:
            second = str(second)
        if len(second) == 2:
            second += '.000'
        elif len(second) == 4:
            second += '00'
        elif len(second) == 5:
            second += '0'
        
        minute = str(minute)
        if len(minute) == 1:
            minute = '0' + minute

        hour = str(hour)
        if len(hour) == 1:
            hour = '0' + hour
        
        return hour + minute + second

    #this will compare the files and output the result
    def comparePath(self):
        pointList = list()
        for point in self.core_entries:
            pointList.append(self.comparePoints(point));

        return pointList


    def comparePoints(self, c):
        minDist = 99999
        point1 = None
        point2 = None
        point3 = None
        for (i, x) in enumerate(self.gps_entries):
            dist = math.sqrt(pow(c.longitude -  x.longitude, 2) + pow(c.latitude -  x.latitude, 2))
            if(dist < minDist):
                minDist = dist
                point1 = x;
                if(i < len(self.gps_entries)-1):
                    point2 = self.gps_entries[i+1]
                if(i > 0):
                    point3 = self.gps_entries[i-1]

        def Pythagoras (x1, y1, x2, y2):
            return math.sqrt(math.pow((x2 - x1), 2)+ math.pow((y2 - y1), 2))

        def DistancePointLine (px, py, x1, y1, x2, y2):
            if(x1 == x2 and y1 == y2):
                return None
            lineLength = Pythagoras(x1, y1, x2, y2)

            u1 = (((px - x1) * (x2 - x1)) + ((py - y1) * (y2 - y1)))
            u = u1 / (lineLength * lineLength)

            if (u < 0) or (u > 1):
                #// closest point does not fall within the line segment, take the shorter distance
                #// to an endpoint
                ix = Pythagoras(px, py, x1, y1)
                iy = Pythagoras(px, py, x2, y2)
                if ix > iy:
                    DistancePointLine = iy
                else:
                    DistancePointLine = ix
            else:
                # Intersecting point is on the line, use the formula
                ix = x1 + u * (x2 - x1)
                iy = y1 + u * (y2 - y1)
                DistancePointLine = Pythagoras(px, py, ix, iy)

            return DistancePointLine

        if point1 is not None:
            if point2 is None and point3 is not None:
                minDist = DistancePointLine(c.longitude, c.latitude, point1.longitude, point1.latitude, point3.longitude, point3.latitude)

            elif point3 is None and point2 is not None:
                minDist = DistancePointLine(c.longitude, c.latitude, point1.longitude, point1.latitude, point2.longitude, point2.latitude)

            elif point3 is None and point3 is None:
                minDist = Pythagoras(c.longitude, c.latitude, point1.longitude, point1.latitude)

            else:
                minDist =  min(
                    DistancePointLine(c.longitude, c.latitude, point1.longitude, point1.latitude, point2.longitude, point2.latitude),
                    DistancePointLine(c.longitude, c.latitude, point1.longitude, point1.latitude, point3.longitude, point3.latitude)
                )

            return minDist

        else:
            return None
    """
    To be called after the metrics have been calculated to output a
    .txt file containing all the results
    """
    def createDataSheet(self):
        filename = self.txtDir + '/result_' + str(self.date.year) + '-' + str(self.date.month) + '-' + str(self.date.day) + '_' + str(self.date.hour) + '-' + str(self.date.minute) + '-' + str(self.date.second) + '.txt' 
        #Sets up path and name for creation of .txt file
        
        f = open(filename, 'w')
        
        txt = 'Scenario ID: ' + str(self.scenarioID) + '\n'
        txt += 'Date: ' + str(self.date) + '\n'
        txt += 'Time taken: ' + str(datetime.utcnow() - self.date) + '\n'
        txt += 'Video files used: '
        #txt += repr(self.videoFileList) [#test.avi, test2.avi, etc.]
        txt += '\n'
        txt += 'GPS log files used: ' + str(self.gpsLog) + '\n'
        txt += 'Asterisk file used: ' + str(self.coreLog) + '\n'
        txt += 'Time offset: ' + str(self.timeOffset) + '\n'
        txt += 'Maximum radius of detection: ' + str(self.maxRadius) + ' meters\n\n'
        
        txt += 'Overall testing results :\n'
        txt = self.printIndividualResult(self.totalResult, txt)

        for i in range(0, len(self.twentyMinuteResults)):
            r = self.twentyMinuteResults[i]
            txt += 'Results from ' + r.startTime[:2] + ':' + r.startTime[2:4] + ':' + r.startTime[4:]
            txt += ' to ' + r.endTime[:2] + ':' + r.endTime[2:4] + ':' + r.endTime[4:] + '\n'
            txt = self.printIndividualResult(r, txt)
	
        f.write(txt)
        f.close()

    #used by createDataSheet
    def printIndividualResult(self, result, txt):
        txt += 'Detection percentage: ' + str(result.detectionPercent) + '%\n'
        txt += 'Positional accuracy (min, max, avg): ' + str(result.minPositonalAccuracy) + ', ' + str(result.maxPositionalAccuracy) + ', ' + str(result.averagePositionalAccuracy) + '\n'
        txt += 'ID changes: ' + str(result.idChanges) + '\n'
        txt += 'Percentage of points within maximum radius: ' + str(result.percentWithinMaxRadius) + '%\n\n'
        return txt

    def export(self):
        f = open('path.kml', 'w')
        i = 0

        kml =   '<?xml version="1.0" encoding="UTF-8"?>\n'
        kml +=  '<kml xmlns="http://www.opengis.net/kml/2.2">\n'
        kml +=      '<Document>\n'
        kml +=          '<name>Paths</name>\n'
        kml +=          '<description>Exported KML file with lines for the GPS and Asterix log files</description>\n'
        kml +=          '<Style id="yellowLineGreenPoly">\n'
        kml +=              '<LineStyle>\n'
        kml +=                  '<color>7f00ffff</color>\n'
        kml +=                  '<width>4</width>\n'
        kml +=              '</LineStyle>\n'
        kml +=              '<PolyStyle>\n'
        kml +=                  '<color>7f00ff00</color>\n'
        kml +=              '</PolyStyle>\n'
        kml +=          '</Style>\n'
        kml +=          '<Style id="redLineGreenPoly">\n'
        kml +=              '<LineStyle>\n'
        kml +=                  '<color>ff0000ff</color>\n'
        kml +=                  '<width>4</width>\n'
        kml +=              '</LineStyle>\n'
        kml +=              '<PolyStyle>\n'
        kml +=                  '<color>7f00ff00</color>\n'
        kml +=              '</PolyStyle>\n'
        kml +=          '</Style>\n'
        kml +=          '<Placemark>'
        kml +=              '<name>GPS Log Path</name>'
        kml +=              '<description>Path generated by the GPS log</description>'
        kml +=              '<styleUrl>#yellowLineGreenPoly</styleUrl>'
        kml +=              '<LineString>'
        kml +=                  '<extrude>1</extrude>'
        kml +=                  '<tessellate>1</tessellate>'
        kml +=                  '<altitudeMode>absolute</altitudeMode>'
        kml +=                  '<coordinates>'
        for entry in self.gps_entries:
            kml += repr(entry.longitude)
            kml += ','
            kml += repr(entry.latitude)
            kml += ',0\n'
        kml +=                  '</coordinates>'
        kml +=              '</LineString>'
        kml +=          '</Placemark>'

		#Iterates over the number of asterisk file entries
        while (i < len(self.core_entries)):
            kml +=          '<Placemark>'
            kml +=              '<name>Core Log TrackNum:'
            kml +=				repr(self.core_entries[i].tn)
            kml +=				'</name>'
            kml +=              '<description>Path generated by the Core log</description>'
            kml +=              '<styleUrl>#redLineGreenPoly</styleUrl>'
            kml +=              '<LineString>'
            kml +=                  '<extrude>1</extrude>'
            kml +=                  '<tessellate>1</tessellate>'
            kml +=                  '<altitudeMode>absolute</altitudeMode>'
            kml +=                  '<coordinates>'
            #Enters the first coordinates of a new track number
            kml += repr(self.core_entries[i].longitude)
            kml += ','
            kml += repr (self.core_entries[i].latitude)
            kml += ',0\n'
            i += 1
            #If the track number changes, stop the loop, and create a new line
            if(i < len(self.core_entries)):
                while (self.core_entries[i-1].tn == self.core_entries[i].tn):
                    print i
                    kml += repr(self.core_entries[i].longitude)
                    kml += ','
                    kml += repr(self.core_entries[i].latitude)
                    kml += ',0\n'
                    i += 1
                    if(i >= len(self.core_entries)):
                        break;
            kml +=                  '</coordinates>'
            kml +=              '</LineString>'
            kml +=          '</Placemark>'
        kml +=      '</Document>\n'
        kml += '</kml>\n'

        f.write(kml)
        f.close()
