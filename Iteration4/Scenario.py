import FileReader
import FileWriter
from Coordinate import Coordinate
from MetricsResult import MetricsResult
import subprocess, math
import time
from datetime import datetime
#import numpy as np
#import matplotlib.pyplot as plt
#from scipy.optimize import fmin_cobyla
#from decimal import *

class Scenario:
    """
    Class containing information for a test scenario

    variables
    scenarioID: the unique identifier for this scenario
    coreLog: the path and filename for the core log used to generate this scenario
    gpsLog: the path and filename for the gps log used to generate this scenario
    timeOffset: the timestamp difference used to compare points in time between the two log files
    maxRadius: the maximum distance a point from the core log can be from a corresponding gps log point for it to be considered accurate
    """
    def __init__ (self, scenarioID, maxRadius, txtDir, kmlDir, gpsLog, coreLog=None, timeOffset=None):
        self.scenarioID = scenarioID
        self.date = datetime.utcnow()
        self.txtDir = txtDir
        self.kmlDir = kmlDir
        self.coreLog = coreLog
        self.gpsLog = gpsLog
        self.timeOffset = timeOffset
        self.maxRadius = maxRadius

    def run(self):
        self.gpsPath = FileReader.parseGpsLog(self.gpsLog)
        if(self.gpsPath == -1):
            return
        print self.gpsPath
        if self.coreLog == None:
            self.coreLog = self.runCamSim()
        self.pathList = FileReader.parseCoreLogs(self.coreLog, self.gpsPath[0].longitude, self.gpsPath[0].latitude)
        if(self.pathList == -1):
            return

        optimalPath = self.getOptimalPath(self.gpsPath, self.pathList)
        distances = self.calculateDistances(optimalPath)
        self.calculateMetrics(optimalPath, distances)
        FileWriter.createDataSheet(self, self.totalResult, self.twentyMinuteResults)
        FileWriter.export(self, self.gpsPath, [optimalPath])
        print "Minimum Distance"
        print min(distances)
        print "Maximum Distance"
        print max(distances)

        print 'id: ', self.scenarioID
        print 'core log file: ', self.coreLog
        print 'gps log file: ', self.gpsLog
        print 'time offset: ', self.timeOffset
        print 'maximum radius: ', self.maxRadius
        print 'number of paths: ', len(self.pathList)

    #this method will call camsim, wait until it completes running, and then return the path and filename that was generated by camsim
    def runCamSim(self):
        #call camsim
        CamSimExe = "CamSimDummyApp.exe"
        CamSimArgs = ["aaa", "bbb", "ccc"]
        subprocess.call([CamSimExe] + CamSimArgs)

        #wait

        #obtain and return path and filename of the log file
        return 'Corefile.log'

    """
    coreLogPath is the list of Coordinates from the path that has been matched with the GPS file
    pathDistances is the list of calculated distances between each point in coreLogPath and the GPS path. The coordinate coreLogPath[i] has a distance of pathDistances[i].

    for now I've assumed that a tracknum of -1 is used in coreLogPath at any point in time when nothing was detected
    this may need to be changed depending on how the path comparison is implemented
    """
    def calculateMetrics(self, coreLogPath, pathDistances):
        print coreLogPath
        print pathDistances
        #all counters with an array of length two have the twenty minute segment counter at index 0 and the total counter at index 1
        #index 0 resets every twenty minutes of footage

        #for calculating the detection percent
        numUndetected = [0,0]

        #for calculating id changes
        previousID = [-1,-1]
        numIDChanges = [-1,-1]

        #for calculating the positional accuracy metrics
        totalDist = [0,0]
        minDist = [99999, 99999]
        maxDist = [-1,-1]
        numAboveRadius = [0,0]

        #used for 20 minute time segments
        timeSegmentStart = coreLogPath[0].time - coreLogPath[0].time%60 #time segments start on the minute
        timeSegmentStartIndex = 0
        self.twentyMinuteResults = []

        for i in range(0, len(coreLogPath)):
            # if 20 minutes have passed, create the results. Then start the next twenty minute segment
            diff = coreLogPath[i].time - timeSegmentStart
            if(diff < 0):
                diff += 24*3600
            if (diff >= 20*60):
                self.twentyMinuteResults.append(self.createResult(i - timeSegmentStartIndex, timeSegmentStart, (timeSegmentStart + 19*60 +59.999)%(24*3600),
                                                         numUndetected[0], numIDChanges[0], minDist[0], maxDist[0], totalDist[0], numAboveRadius[0]))
                timeSegmentStartIndex = i
                timeSegmentStart = (timeSegmentStart + 20*60)%(24*3600)

                #reset all twenty minute segment counters
                numUndetected[0] = 0
                previousID[0] = -1
                numIDChanges[0] = -1
                totalDist[0] = 0
                minDist[0] = 99999
                maxDist[0] = -1
                numAboveRadius[0] = 0

            if coreLogPath[i].tn < 0:
                numUndetected[0] += 1
                numUndetected[1] += 1
            else:
                if coreLogPath[i].tn != previousID[0]:
                    previousID[0] = coreLogPath[i].tn
                    numIDChanges[0] += 1
                if coreLogPath[i].tn != previousID[1]:
                    previousID[1] = coreLogPath[i].tn
                    numIDChanges[1] += 1
                totalDist[0] += pathDistances[i]
                totalDist[1] += pathDistances[i]
                if pathDistances[i] < minDist[0]:
                    minDist[0] = pathDistances[i]
                if pathDistances[i] < minDist[1]:
                    minDist[1] = pathDistances[i]
                if pathDistances[i] > maxDist[0]:
                    maxDist[0] = pathDistances[i]
                if pathDistances[i] > maxDist[1]:
                    maxDist[1] = pathDistances[i]
                if pathDistances[i] > self.maxRadius:
                    numAboveRadius[0] += 1
                    numAboveRadius[1] += 1

        #add last segment
        self.twentyMinuteResults.append(self.createResult(len(coreLogPath) - timeSegmentStartIndex, timeSegmentStart, coreLogPath[len(coreLogPath) - 1].time,
                                                 numUndetected[0], numIDChanges[0], minDist[0], maxDist[0], totalDist[0], numAboveRadius[0]))

        #create the total result
        self.totalResult = self.createResult(len(coreLogPath), coreLogPath[0].time - coreLogPath[0].time%60, coreLogPath[len(coreLogPath) - 1].time,
                                         numUndetected[1], numIDChanges[1], minDist[1], maxDist[1], totalDist[1], numAboveRadius[1])


    #helper method for calculateMetrics
    def createResult(self, length, startTime, endTime, numUndetected, numIDChanges, minDist, maxDist, totalDist, numAboveRadius):
        detectionPercent = float(length - numUndetected) / length * 100
        if length - numUndetected > 0:
            averageDist = totalDist / float(length - numUndetected)
            percentWithinMaxRadius = ((length - numUndetected) - numAboveRadius) / float(length - numUndetected) * 100
        else:
            averageDist = -1
            percentWithinMaxRadius = -1
        result = MetricsResult(startTime, endTime, detectionPercent, numIDChanges, minDist, maxDist, averageDist, percentWithinMaxRadius)
        return result

    #takes a numeric value of milliseconds and returns a string in the format HH:MM:SS.mmm
    def timeToString(self, time):
        hh = str(int(time/3600))
        if len(hh) == 1:
            hh = '0' + hh
        
        mm = str(int(time%3600 / 60))
        if len(mm) == 1:
            mm = '0' + mm
        
        ss = str(int(time%60))
        if len(ss) == 1:
            ss = '0' + ss

        mill = str(time%1)
        if(len(mill) >= 5):
            mill = mill[2:5]
        elif(len(mill) == 4):
            mill = mill[2:4] + '0'
        elif(len(mill) == 3):
            mill = mill[2] + '00'
        elif(len(mill) < 3):
            mill = '000'

        return hh + ':' + mm + ':' + ss + '.' + mill
        

    #Computes a list of distances between any path and the desired gps path
    def calculateDistances(self, path):
        pointList = list()
        for point in path:
            pointList.append(self.comparePointToPath(self.gpsPath, point));

        return pointList

    def Pythagoras (self, x1, y1, x2, y2):
        return math.sqrt(math.pow((x2 - x1), 2) + math.pow((y2 - y1), 2))

    def getOptimalPath(self, gpsPath, pathList):
        paths = self.getPotentialInitialSegments(gpsPath, pathList)

        pathEval = float('inf')
        optimalPath = None
        for (i, path) in enumerate(paths):
            path = paths[i]
            print "Processing path " + str(i) + "/" + str(len(paths))
            newPath = self.getMatchingPath(gpsPath, pathList, path)
            newPathEval = self.evaluatePath(gpsPath, newPath)
            if newPathEval < pathEval:
                pathEval = newPathEval
                optimalPath = newPath
            i+=1
        return optimalPath

    def getPotentialInitialSegments(self, gpsPath, pathList):
        paths = list()
        for (j, path) in enumerate(pathList):
            i = 0
            k = 2
            index = 0
            distance = float('inf')
            while(i < len(path)):
                tempDist = self.comparePointToPath(gpsPath[:],path[i])
                if tempDist < distance:
                    distance = tempDist
                    index = i
                i+=1
            if(distance < self.maxRadius):
                paths.append((j, path[index:]))
                print 'new path ' + str(j)
        return paths

    def getMatchingPath(self, gpsPath, pathList, pathTuple):
        index = pathTuple[0]
        path = pathTuple[1]
        #Getting cutoff point for path
        cutoff = 0
        offset = float(path[0].time) - float(gpsPath[0].time)
        for (i, point) in enumerate(gpsPath):
            if(float(path[len(path)-1].time) >= offset+float(gpsPath[i].time)):
                if(i < len(gpsPath)-1):
                    if(float(path[len(path)-1].time) <= offset+float(gpsPath[i+1].time)):
                        cutoff = i
                        break
                else:
                    print "Exit 1"
                    return path

        while(not self.pathComplete(gpsPath, path)):
            newSegmentTuple = self.getBestSegment(gpsPath[cutoff:], pathList[index+1:])
            if(newSegmentTuple[1] is None):
                break
            index = index+1+newSegmentTuple[0]
            path.extend(newSegmentTuple[1])
            #Re-calculate cutoff point after adding points to the optimal path
            for (i, point) in enumerate(gpsPath):
                if(float(path[len(path)-1].time) >= offset+float(gpsPath[i].time)):
                    if(i < len(gpsPath)-1):
                        if(float(path[len(path)-1].time) <= offset+float(gpsPath[i+1].time)):
                            cutoff = i
                            break
                    else:
                        print "Exit 2"
                        return path
        return path

    def evaluatePath(self, path, matchedPath):
        result = 0
        for point in path:
            val = self.comparePointToPath(matchedPath, point)
            if(val is not None):
                result += val

        result = result/len(path)
        return result

    def pathComplete(self, gpsPath, path):
        pathTime = float(path[len(path)-1].time) - float(path[0].time)
        gpsTime = float(self.gpsPath[len(gpsPath)-1].time) - float(gpsPath[0].time)
        if(pathTime > gpsTime):
            print "PATH IS COMPLETE"
            print "pathTime " + str(pathTime)
            print "gpsTime " + str(gpsTime)
        return pathTime > gpsTime

    #Returns segment from segments that best matches path, from the very first point
    def getBestSegment(self, path, segments):
        segment = None
        index = None
        distance = float('inf')
        for (i, s) in enumerate(segments):
            tempDistance = self.comparePointToPath(path, s[0])
            if(tempDistance < distance):
                segment = s
                index = i
                distance = tempDistance
        return (index, segment)

    #Calculates distance from a point to a line. Special cases are tricky.
    def comparePointToPath(self, path, c):
        minDist = 99999     #Initial value for minDist has to be maximum value possible, so it always goes down
        point1 = None
        point2 = None
        point3 = None

        #Compare all points in the GPS logs to the point c given
        #find closest point

        for (i, x) in enumerate(path):

            dist = self.Pythagoras(x.x, x.y, c.x, c.y)
            if(dist < minDist):
                point1 = None
                point2 = None
                point3 = None

                minDist = dist
                point1 = x;
                if(i < len(path)-1):
                    point2 = path[i+1]
                if(i > 0):
                    point3 = path[i-1]


        def DistancePointLine (px, py, x1, y1, x2, y2):
            if(x1 == x2 and y1 == y2):
                return self.Pythagoras(px, py, x1, y1)
            lineLength = self.Pythagoras(x1, y1, x2, y2)

            u1 = (((px - x1) * (x2 - x1)) + ((py - y1) * (y2 - y1)))
            u = u1 / (lineLength * lineLength)

            if (u < 0) or (u > 1):
                #closest point does not fall within the line segment, take the shorter distance
                #to an endpoint
                ix = self.Pythagoras(px, py, x1, y1)
                iy = self.Pythagoras(px, py, x2, y2)
                if ix > iy:
                    DistancePointLine = iy
                else:
                    DistancePointLine = ix
            else:
                # Intersecting point is on the line, use the formula
                ix = x1 + u * (x2 - x1)
                iy = y1 + u * (y2 - y1)
                DistancePointLine = self.Pythagoras(px, py, ix, iy)

            return DistancePointLine

        if point1 is not None:
            if point2 is None and point3 is not None:
                minDist = DistancePointLine(c.x, c.y, point1.x, point1.y, point3.x, point3.y)

            elif point2 is not None and point3 is None:
                minDist = DistancePointLine(c.x, c.y, point1.x, point1.y, point2.x, point2.y)

            elif point2 is None and point3 is None:
                minDist = self.Pythagoras(c.x, c.y, point1.x, point1.y)

            else:
                minDist =  min(
                    DistancePointLine(c.x, c.y, point1.x, point1.y, point2.x, point2.y),
                    DistancePointLine(c.x, c.y, point1.x, point1.y, point3.x, point3.y)
                )
            return minDist

        else:
            return None

    def test(self, pathList, p):
        print p.longitude
        print p.latitude
        a = list()
        for path in pathList:
            for point in path:
                a.append((self.Pythagoras(p.longitude, p.latitude, point.longitude, point.latitude), point.longitude, point.latitude))

        a.sort(key=lambda point:point[0])
        print a[:100]